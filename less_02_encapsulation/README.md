### Инкапсуляция

3 кита ООП:
1. Инкапсуляция *
2. Наследование
3. Полиморфизм


Изучение этих принципов необходимо, чтобы писать удобные и понятные классы.

### Инкапсуляция подразумевает:
1. Все данные и методы для работы с ними находятся в одном месте (классе, экземпляре)
2. Предоставление публичного API (ПУБЛИЧНЫХ методов для работы с классом, экземпляром)


### Инкапсуляция в python НЕ ПОДРАЗУМЕВАЕТ:
1. Сокрытие данных

### Тип написания имени метода

Показывает пользователю какие методы являются публичными, а какие для внутреннего пользования
```
text = "4695487"
print(dir(text))

[
'__add__', '__class__', '__contains__', '__delattr__', '__dir__',
'__doc__', '__eq__', '__format__', '__ge__', '__getattribute__',
'__getitem__', '__getnewargs__', '__getstate__', '__gt__', '__hash__',
'__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__',
'__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__',
'__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__',
'__subclasshook__',
'capitalize', 'casefold', 'center', 'count', 'encode',
'endswith', 'expandtabs', 'find', 'format', 'format_map',
'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal',
'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 
'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip',
'maketrans', 'partition', 'removeprefix', 'removesuffix', 'replace',
'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split',
'splitlines', 'startswith', 'strip', 'swapcase', 'title',
'translate', 'upper', 'zfill'
]
```
Любой объект гарантирует работу при использовнии публичного интерфейса
(с помощью методов и атрибутов у которых нет подчеркиваний)

Почему так?

```Релизация приватных атрибутов и методов может меняться```

И если мы опираемся на них, при создании нашего приложения, то мы рискуем,
т.к. при обновлении python, например, внутренняя реализация приватных
методов может поменяться.

Нам гарантируют только, то что публичные методы будут работать так, как заявлено.

Публичный API (интерфейс) - это контракт, все методы которого будут работать,
внутренняя же реализация не гарантирована.

## Name mangling
Name mangling — это процесс, при котором Python
автоматически «прячет» «приватные» атрибуты класса, изменяя их имена.

Например, в классе MyClass атрибут ```__private_var```
будет автоматически переименован в ```_MyClass__private_var```.
Попытка обратиться к __private_var напрямую приведёт к ошибке.

```
Несмотря на «name mangling», доступ к «приватным» атрибутам всё ещё возможен,
если знать, как Python переименовывает их.
```
Поэтому двойное подчёркивание не делает атрибуты класса абсолютно недоступными,
а лишь затрудняет к ним доступ.

```
Старайся избегать Name mangling-a т.к. он, хоть и бывает полезен,
но конфликтует с zen python
```
> "Явное лучше неявного"

### Основная цель создания Name mangling:
В том чтобы данный атрибут не наследовался (см. урок про Наследование)

### Советы:
1. Делать одно _ для внутренних атрибутов и реализаций
2. Не перебарщивай с __ и сеттерами/геттерами

Сеттеры/геттеры нужно писать только в том случае,
если в этом есть необходимость.

(Дело в том, что часто дают вредный совет везде писать
двойные подчеркивания и добавлять сеттеры/геттеры...
Так пишут в Java, но не в Python...
Но такой подход просто загромождает питоновский код...
Вместо этого создавай протектед атрибут без всяких сеттеров и геттеров...
А вообще нужно хорошо продумывать свой класс, возможно 
в некоторых случаях лучше будет сделать атрибут публичным...
все это зависит от ситуации...)
